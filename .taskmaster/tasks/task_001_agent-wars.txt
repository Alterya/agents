# Task ID: 1
# Title: Shared: Database schema and Prisma models
# Status: review
# Dependencies: None
# Priority: high
# Description: Design and implement Postgres schema and Prisma models for Agent, Conversation, Message, RunReport, and PromptTemplate, including migrations, seed data for prebuilt agents, and basic data-access utilities.
# Details:
Implementation subtasks (target 5):
1) Implement schema + migrations
- Use Prisma v5.x with Postgres. Entities and fields:
  - Agent: id (cuid, PK), name (string, unique), description (string), systemPrompt (text), persona (json), createdAt, updatedAt, isActive (bool), tags (string[])
  - Conversation: id (cuid, PK), agentId (FK->Agent), model (string), systemPrompt (text), goal (text), goalReached (bool, default false), endedReason (enum: 'goal'|'limit'|'error'|'manual'|'timeout'), messageLimit (int, default 25), messageCount (int, default 0), runId (string|null), startedAt, endedAt (date|null)
  - Message: id (cuid, PK), conversationId (FK->Conversation), role (enum: 'system'|'user'|'assistant'|'tool'), content (text), tokensIn (int|null), tokensOut (int|null), costUsd (decimal(10,5)|null), createdAt
  - RunReport: id (cuid, PK), runId (string, unique), agentId (FK->Agent), model (string), systemPrompt (text), runCount (int), failures (json), summary (text), revisedPrompt (text), stats (json), createdAt
  - PromptTemplate: id (cuid, PK), name (string, unique), description (string), template (text), variables (string[]), lastUsedAt (date|null), createdAt, updatedAt
- Indexes: Conversation(agentId), Message(conversationId, createdAt), Agent(name), RunReport(runId)
- Prisma schema (pseudo):
  model Agent { id String @id @default(cuid()) name String @unique description String? systemPrompt String persona Json? isActive Boolean @default(true) tags String[] @default([]) conversations Conversation[] createdAt DateTime @default(now()) updatedAt DateTime @updatedAt }
  model Conversation { id String @id @default(cuid()) agentId String agent Agent @relation(fields: [agentId], references: [id]) model String systemPrompt String? goal String? goalReached Boolean @default(false) endedReason EndReason? messageLimit Int @default(25) messageCount Int @default(0) runId String? startedAt DateTime @default(now()) endedAt DateTime? messages Message[] @@index([agentId]) }
  enum EndReason { goal limit error manual timeout }
  model Message { id String @id @default(cuid()) conversationId String conversation Conversation @relation(fields: [conversationId], references: [id]) role Role content String tokensIn Int? tokensOut Int? costUsd Decimal? @db.Decimal(10,5) createdAt DateTime @default(now()) @@index([conversationId, createdAt]) }
  enum Role { system user assistant tool }
  model RunReport { id String @id @default(cuid()) runId String @unique agentId String agent Agent @relation(fields: [agentId], references: [id]) model String systemPrompt String? runCount Int failures Json? summary String? revisedPrompt String? stats Json? createdAt DateTime @default(now()) }
  model PromptTemplate { id String @id @default(cuid()) name String @unique description String? template String variables String[] @default([]) lastUsedAt DateTime? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt }
- Run: npx prisma migrate dev -n init

2) Seed and minimal data-access utils
- Create prisma/seed.ts to insert 3–5 prebuilt Agents with distinct personas.
- Add lightweight repository helpers (e.g., getActiveAgents, createConversation, appendMessage, completeConversation, saveRunReport, upsertPromptTemplate).

3) Cleanup
- Remove sample data not used in MVP, ensure nullable fields match usage, verify cascade delete behavior (prefer ON DELETE CASCADE for Message on Conversation).

4) Quality Gate (run tests/lint)
- Add scripts: prisma:generate, prisma:migrate, prisma:seed. Run typecheck. Ensure Prisma Client generated.

5) Context7 MCP research for external packages/libraries used
- Prisma v5 docs, Neon/Supabase connection pool guidance for serverless (use pgbouncer/pooler or Prisma Data Proxy). Verify Vercel Postgres/Neon best practices; ensure DATABASE_URL uses connection pooling.

<info added on 2025-08-11T15:37:22.943Z>
Enhancements (research-backed):

- Schema additions and changes (Prisma v5, Postgres):
  - Message: add seq Int (monotonically increasing per conversation), @@index([conversationId, seq]); keep existing @@index([conversationId, createdAt]). In appendMessage, assign seq transactionally as max(seq)+1 for the conversation to support incremental polling.
  - Conversation: add tokensInTotal Int @default(0), tokensOutTotal Int @default(0), costUsdTotal Decimal? @db.Decimal(12,6) @default(0).
  - RunReport: add tokensInTotal Int @default(0), tokensOutTotal Int @default(0), costUsdTotal Decimal? @db.Decimal(12,6) @default(0).
  - Enums:
    - JudgeMode { auto, human, hybrid }
    - BattleWinner { A, B, draw, undecided }
  - Battle:
    - id String @id @default(cuid())
    - conversationAId String, conversationBId String
    - conversationA Conversation @relation(fields: [conversationAId], references: [id])
    - conversationB Conversation @relation(fields: [conversationBId], references: [id])
    - participantA Json?, participantB Json?
    - goal String?
    - winner BattleWinner?
    - endedReason EndReason?
    - judgeMode JudgeMode?
    - judgeRationale String?
    - metrics Json?
    - isBlind Boolean @default(true)
    - createdAt DateTime @default(now()), updatedAt DateTime @updatedAt
    - judgeDecisions JudgeDecision[]
    - @@index([conversationAId]), @@index([conversationBId])
  - JudgeDecision:
    - id String @id @default(cuid())
    - battleId String
    - battle Battle @relation(fields: [battleId], references: [id])
    - evaluationRunId String?
    - evaluationRun EvaluationRun? @relation(fields: [evaluationRunId], references: [id])
    - judgeMode JudgeMode
    - winner BattleWinner
    - rationale String?
    - metrics Json?
    - createdAt DateTime @default(now())
    - failureTags DecisionFailureTag[] (m:n)
    - @@index([battleId]), @@index([evaluationRunId])
  - EvaluationRun:
    - id String @id @default(cuid())
    - name String @unique
    - description String?
    - judgeMode JudgeMode?
    - isBlind Boolean @default(true)
    - config Json?
    - stats Json?
    - createdAt DateTime @default(now()), updatedAt DateTime @updatedAt
    - decisions JudgeDecision[]
    - metrics EvaluationMetric[]
  - EvaluationMetric:
    - id String @id @default(cuid())
    - evaluationRunId String
    - run EvaluationRun @relation(fields: [evaluationRunId], references: [id])
    - key String
    - value Float?
    - details Json?
    - createdAt DateTime @default(now())
    - @@index([evaluationRunId])
  - FailureTag:
    - id String @id @default(cuid())
    - slug String @unique
    - description String?
  - DecisionFailureTag (join table):
    - judgeDecisionId String
    - failureTagId String
    - judgeDecision JudgeDecision @relation(fields: [judgeDecisionId], references: [id])
    - failureTag FailureTag @relation(fields: [failureTagId], references: [id])
    - @@id([judgeDecisionId, failureTagId])
    - @@index([failureTagId])
  - Rating:
    - id String @id @default(cuid())
    - subject String @unique
    - mu Float
    - sigma Float
    - games Int @default(0)
    - createdAt DateTime @default(now()), updatedAt DateTime @updatedAt

- Repository helpers (add/modify):
  - appendMessage: within a transaction, compute next seq for the conversation (SELECT max(seq)+1 FOR UPDATE or equivalent), insert Message with seq, and increment Conversation.messageCount plus aggregate totals (tokensInTotal, tokensOutTotal, costUsdTotal).
  - getMessagesSinceSeq(conversationId: string, sinceSeq: number, limit = 100): returns messages where seq > sinceSeq ordered by seq asc (uses @@index([conversationId, seq])).
  - completeConversation: no change beyond existing behavior.
  - saveRunReport: accept tokensInTotal?, tokensOutTotal?, costUsdTotal? and persist; if not provided, compute aggregates from related conversations/messages where applicable.
  - Battle helpers: createBattle({ conversationAId, conversationBId, participantA?, participantB?, goal?, isBlind? }), recordJudgeDecision({ battleId, evaluationRunId?, judgeMode, winner, rationale?, metrics?, failureTagSlugs?: string[] }).
  - Rating helpers: upsertRating({ subject, mu, sigma, games? }).

- Indexing:
  - Maintain Message @@index([conversationId, createdAt]).
  - Add Message @@index([conversationId, seq]). If seq cannot be set for legacy messages, fallback read path may use @@index([conversationId, id]) temporarily.

- Cost and usage aggregation:
  - Store per-message tokens and cost as already defined; update Conversation and RunReport aggregate totals on each message append and on run report save. Ensure Decimal precision is sufficient for totals (12,6 recommended).

- Serverless Prisma pooling and env:
  - Use pooled DATABASE_URL with pgbouncer=true, connection_limit=1, sslmode=require, connect_timeout=5 (or similar). Use DIRECT_URL (non-pooled) for prisma migrate/studio.
  - Consider Prisma Accelerate/Data Proxy for Edge or higher concurrency; if enabled, add the accelerate generator and route reads accordingly.
  - Example:
    - DATABASE_URL=postgresql://user:pass@pool-host/db?sslmode=require&pgbouncer=true&connection_limit=1&connect_timeout=5
    - DIRECT_URL=postgresql://user:pass@direct-host/db?sslmode=require

- Migrations:
  - Create a follow-up migration adding new models, enums, fields, and indexes (e.g., npx prisma migrate dev -n eval_battles_seq_aggregates). Backfill seq for existing messages per conversation using a window function or application-side script.

- Tests (augment):
  - Verify Message.seq is strictly increasing per conversation under concurrency; getMessagesSinceSeq returns correct window.
  - Validate aggregate totals update on Conversation and RunReport.
  - CRUD for Battle, JudgeDecision, EvaluationRun, EvaluationMetric, FailureTag, Rating; m:n tagging works.
  - Index usage: EXPLAIN on messages since seq and standard read path.

- Research references:
  - Add .taskmaster/docs/research notes summarizing Prisma pooling (pgbouncer, pooled vs direct URLs, connection_limit) and the evaluation/battle schema rationale with links to source docs and examples.
</info added on 2025-08-11T15:37:22.943Z>
<info added on 2025-08-12T08:46:07.814Z>
Project-wide tooling baseline (free/local) to add:

- Linters (ESLint)
  - Dev deps: eslint, eslint-config-next, @typescript-eslint/eslint-plugin, @typescript-eslint/parser, eslint-plugin-react, eslint-plugin-react-hooks, eslint-plugin-jsx-a11y, eslint-plugin-import-x (or eslint-plugin-import), eslint-config-prettier, eslint-plugin-tailwindcss
  - .eslintrc: extends next/core-web-vitals, plugin:@typescript-eslint/recommended, plugin:react/recommended, plugin:react-hooks/recommended, plugin:jsx-a11y/recommended, plugin:import-x/recommended, plugin:tailwindcss/recommended, prettier
  - Rules: tailwindcss/no-contradicting-classname error; import/order via import-x with groups and alphabetize; react/react-in-jsx-scope off; no restricted imports to enforce relative path hygiene as needed
  - Parser: @typescript-eslint/parser with project tsconfig; env browser, node, es2022, jest; settings react version detect; ignore patterns for .next, dist, coverage, prisma/generated

- Formatters (Prettier)
  - Dev deps: prettier, prettier-plugin-tailwindcss
  - .prettierrc: include prettier-plugin-tailwindcss and standard style (semi true, singleQuote true, trailingComma all)
  - Ensure eslint-config-prettier is last in ESLint extends

- Unit/integration tests
  - Dev deps: vitest, @testing-library/react, @testing-library/user-event, @testing-library/jest-dom, msw, @vitest/coverage-v8
  - vitest config: environment jsdom; setupFiles to load jest-dom and MSW server (start/stop/reset handlers)
  - Add tests covering repository helpers against a test Postgres (Docker or Neon branch), aligned with this task’s test strategy

- E2E and QA
  - Dev deps: @playwright/test, @axe-core/playwright, @lhci/cli
  - Playwright config with projects for Chromium/WebKit/Firefox; global a11y check via axe on key pages
  - Lighthouse CI: add lighthouserc with PRD-defined budgets (e.g., TTI, TBT, CLS, LCP thresholds)

- Prisma workflow
  - Standardize scripts for prisma format, validate, migrate, generate, seed
  - Test DB options: Docker Postgres service (preferred locally) or Neon branch URL; use DIRECT_URL for migrate/studio and pooled DATABASE_URL for runtime

- Optional Python worker (if enabled)
  - Tools: ruff, black, isort, pytest
  - Config files: pyproject.toml with tool.black, tool.isort (profile black), tool.ruff rules; pytest.ini basic config
  - Make targets to lint/format/test Python code under ./worker or similar

- Makefile (top-level) to orchestrate common flows
  - install: package manager install
  - lint: ESLint; lint:fix: ESLint with fix
  - format and format:check: Prettier
  - typecheck: tsc --noEmit
  - test: Vitest run; test:watch; coverage
  - e2e: Playwright run; e2e:report
  - prisma:generate, prisma:validate, prisma:migrate, prisma:seed
  - db:up, db:down, db:reset for local Docker Postgres
  - a11y: Playwright + axe run on critical routes
  - lighthouse: lhci autorun using budgets
  - ci: sequence covering generate -> migrate (DIRECT_URL) -> seed -> typecheck -> lint -> unit tests -> e2e (optional) -> lhci

- package.json scripts (baseline)
  - lint, lint:fix, format, format:check, typecheck, test, test:watch, coverage, e2e, e2e:report, prisma:generate, prisma:validate, prisma:migrate, prisma:seed, lhci
  - prisma seed hook: { "prisma": { "seed": "tsx prisma/seed.ts" } }

- Output Policy for Prompt agents
  - No hidden reasoning in outputs
  - If a required fact or tool is missing and the user insists, reply exactly: information unavailable

Refer to PRD section “Local Tooling Stack” for thresholds, conventions, and any additional rules to mirror across repos.
</info added on 2025-08-12T08:46:07.814Z>
<info added on 2025-08-12T09:09:36.786Z>
Quality-Gate Loop (pre-commit enforced)
- a) Cleanup
  - Remove redundant/unused files, dead code paths, and obsolete sample data.
  - Update .gitignore to exclude: node_modules, .next, dist, coverage, prisma/generated, .env, .env.*, .DS_Store, tmp, .vercel, .turbo (if present).
  - Update README: quickstart for Prisma (migrate/generate/seed), pooled vs DIRECT_URL env usage, test DB setup, and the Quality-Gate workflow below.
- b) Self-Review
  - Inspect the full diff. Verify each subtask deliverable exists, compiles, and is coherent:
    - prisma/schema.prisma reflects all models/enums/indexes including seq, aggregates, and evaluation/battle entities.
    - Migrations: initial + follow-up (eval_battles_seq_aggregates) present; backfill plan/script for seq noted.
    - Seed inserts 3–5 agents with distinct personas.
    - Repository helpers implemented with transactions and basic error handling; tests cover core paths and concurrency for seq.
    - Scripts in package.json and Makefile targets exist and run (including prisma:generate/migrate/seed).
    - .env.example includes DATABASE_URL (pooled) and DIRECT_URL (non-pooled).
  - Run locally: make quality and make test; both must pass.
- c) Git add & commit (DO NOT PUSH)
  - Stage logically grouped changes and create descriptive commits (e.g., prisma: initial schema+migration; repo: helpers+tests; migrations: eval/battles/aggregates; seed: prebuilt agents; tooling: Makefile+pre-commit; docs: README+.env.example).
  - Use conventional “scope: summary” style with concise bodies; note any breaking changes.
- Pre-commit enforcement
  - Add a pre-commit hook that runs: make quality && make test.
  - If using Husky: dev-install husky and add .husky/pre-commit with the above command. If not, add .git/hooks/pre-commit shell script invoking the same command (ensure executable).
  - Makefile: add a quality target (or alias quality to check) that runs prisma format, prisma validate, typecheck, eslint (no fix), and prettier --check to ensure consistency before commit.
</info added on 2025-08-12T09:09:36.786Z>

# Test Strategy:
- Unit: Vitest tests for repository helpers using a test Postgres (Docker) or Neon branch DB.
- Migration validation: Apply migrations on a fresh DB, run basic CRUD flows.
- Seed sanity: Ensure at least one Agent present and selectable.
- Performance: Verify indexes via EXPLAIN on Message read path.
- Rollback: Test down migration and re-apply without data loss for non-critical fields.

# Subtasks:
## 1. Implement Prisma schema and initial migration [review]
### Dependencies: None
### Description: Define Prisma v5 schema for Agent, Conversation, Message, RunReport, and PromptTemplate with enums, relations, indexes, defaults, and cascade rules. Generate the initial migration and Prisma Client.
### Details:
Tasks:
- Create prisma/schema.prisma with datasource (provider: postgresql) and generator client.
- Models:
  - Agent: id(cuid, PK), name(unique), description?, systemPrompt, persona(Json?), isActive(default true), tags(String[] default []), conversations(Conversation[]), createdAt(now), updatedAt(@updatedAt).
  - Conversation: id(cuid), agentId(FK->Agent), model, systemPrompt?, goal?, goalReached(default false), endedReason(enum EndReason?), messageLimit(default 25), messageCount(default 0), runId?, startedAt(now), endedAt?, messages(Message[]); @@index([agentId]).
  - Message: id(cuid), conversationId(FK->Conversation onDelete: Cascade), role(enum Role), content(text), tokensIn?, tokensOut?, costUsd Decimal @db.Decimal(10,5)?, createdAt(now); @@index([conversationId, createdAt]).
  - RunReport: id(cuid), runId(unique), agentId(FK->Agent), model, systemPrompt?, runCount, failures(Json?), summary?, revisedPrompt?, stats(Json?), createdAt(now).
  - PromptTemplate: id(cuid), name(unique), description?, template, variables(String[] default []), lastUsedAt?, createdAt(now), updatedAt(@updatedAt).
  - Enums: EndReason { goal, limit, error, manual, timeout }, Role { system, user, assistant, tool }.
- Create indexes per spec: Conversation(agentId), Message(conversationId, createdAt), Agent(name unique), RunReport(runId unique).
- Run: npx prisma migrate dev -n init; then npx prisma generate.

Tag: backend

<plan added on 2025-08-13T08:15:07.765Z>
Plan for 1.1 (Implement Prisma schema and initial migration):
- Create prisma/schema.prisma with models: Agent, Conversation, Message, RunReport, PromptTemplate; enums Role, EndReason.
- Add @prisma/client to dependencies and tsx to devDependencies in agents_wars/web/package.json.
- Add prisma seed hook: { "prisma": { "seed": "tsx prisma/seed.ts" } }.
- Create prisma/seed.ts to insert 3–5 prebuilt Agents.
- Run: npm run prisma:format && npm run prisma:generate.
- Prepare .env with DATABASE_URL (pooled) and DIRECT_URL for future migrations.

<log added on 2025-08-13T08:29:05.834Z>
Non-Docker setup for Prisma (macOS/local):
1) Install a local Postgres (e.g., Postgres.app or Homebrew).
2) Create DB/user (example):
   createdb agentwars
   psql -d postgres -c "CREATE USER agentwars WITH PASSWORD 'agentwars';"
   psql -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE agentwars TO agentwars;"
3) Update src/agents_wars/web/.env with your real credentials for DATABASE_URL and DIRECT_URL.
4) From web/:
   - npm run prisma:migrate  (first run will create initial migration)
   - npm run prisma:seed     (optional)
   - npm run prisma:studio   (optional)

When DB is configured, I will run migrate + seed and complete 1.1.


## 2. Seed prebuilt agents and implement minimal repository helpers [review]
### Dependencies: 1.1
### Description: Add seed script to insert 3–5 prebuilt Agents with distinct personas, and implement lightweight data-access utilities for common operations.
### Details:
Tasks:
- Create prisma/seed.ts inserting 3–5 Agents (e.g., Generalist, Prompt Tuner, Evaluator, Researcher, Code Reviewer) with unique name, systemPrompt, persona JSON, tags.
- Implement repository helpers (e.g., src/lib/db or src/repo):
  - getActiveAgents(): Promise<Agent[]>.
  - createConversation({ agentId, model, systemPrompt?, goal?, messageLimit? }): Promise<Conversation>.
  - appendMessage(conversationId, { role, content, tokensIn?, tokensOut?, costUsd? }): Promise<Message> (increment messageCount in a transaction).
  - completeConversation(conversationId, { endedReason, goalReached, endedAt? }): Promise<Conversation>.
  - saveRunReport({ runId, agentId, model, systemPrompt?, runCount, failures?, summary?, revisedPrompt?, stats? }): Promise<RunReport>.
  - upsertPromptTemplate({ name, description?, template, variables }): Promise<PromptTemplate> (upsert by unique name).
- Ensure types are inferred from Prisma Client; add basic error handling for unique constraint violations.

Tag: backend

## 3. Cleanup and alignment with MVP [review]
### Dependencies: 1.1, 1.2
### Description: Remove unused sample data, confirm nullable fields and defaults match usage, verify cascade behavior and indexes, and adjust schema if needed.
### Details:
Tasks:
- Remove any unused sample models/data. Confirm optional fields (e.g., description?, systemPrompt? on Conversation, RunReport) and defaults (goalReached=false, messageLimit=25, messageCount=0).
- Verify onDelete: Cascade for Message->Conversation; keep Agent->Conversation as Restrict (or explicit NoAction) to avoid accidental loss; document behavior.
- Re-run prisma format and generate a follow-up migration if tweaks are required.
- Validate indexes: Conversation(agentId), Message(conversationId, createdAt), Agent(name unique), RunReport(runId unique).

Tag: backend

## 4. Quality gate: scripts, generate client, typecheck, lint, and repository tests [review]
### Dependencies: 1.1, 1.2, 1.3
### Description: Add package scripts, ensure Prisma Client generation, and run typecheck/lint plus Vitest repository tests against a test Postgres.
### Details:
Tasks:
- package.json scripts: prisma:generate (prisma generate), prisma:migrate (prisma migrate dev), prisma:seed (prisma db seed), test (vitest run), typecheck (tsc --noEmit), lint (eslint .).
- Configure Prisma seed hook: package.json { "prisma": { "seed": "tsx prisma/seed.ts" } } (or ts-node).
- Test DB: Docker Postgres or Neon branch; set DATABASE_URL (dev), DATABASE_URL_TEST (CI). Use DIRECT_URL for migrations if using a pooler.
- Vitest: tests for getActiveAgents, createConversation + appendMessage (transaction + counter), completeConversation (ended flags/reason), upsertPromptTemplate (id stable on repeat), saveRunReport (unique runId).
- Ensure prisma generate runs before tests and CI uses fresh DB with migrations and seed.

Tag: backend

## 5. Context7 MCP research: Prisma v5 + serverless Postgres pooling [review]
### Dependencies: None
### Description: Research and document best practices for Prisma v5 with Postgres on Neon/Supabase/Vercel, focusing on connection pooling and environment configuration.
### Details:
Scope:
- Docs to review: Prisma v5 (PostgreSQL, Accelerate/Data Proxy), Neon pgbouncer/pooler, Vercel Postgres with Prisma, Supabase pooled connections.
- Recommendations:
  - Use a pooled DATABASE_URL in serverless (Neon/Vercel pooler or Supabase pooler port 6543) to prevent connection storms; use DIRECT_URL for migrations.
  - For PgBouncer, add connection string params: pgbouncer=true, sslmode=require, connection_timeout/pgbouncer settings; disable prepared statements if needed via ?pgbouncer=true.
  - Consider Prisma Accelerate/Data Proxy in high-concurrency serverless; configure generator accelerate if adopted.
  - CI/CD: run migrations in a controlled step using DIRECT_URL (non-pooled) to avoid pooler limitations.
- Example env:
  - DATABASE_URL=postgresql://user:pass@neon-pool-host/db?sslmode=require&pgbouncer=true&connect_timeout=5
  - DIRECT_URL=postgresql://user:pass@neon-direct-host/db?sslmode=require
  - For Supabase: use pooled url (port 6543) as DATABASE_URL; non-pooled as DIRECT_URL for migrations.
- Notes: keep relationMode=foreignKeys; ensure Decimal(10,5) is supported; avoid long-running transactions in serverless.

Tag: backend

<research added on 2025-08-13T09:14:02.798Z>
Prisma v5 + serverless Postgres pooling notes saved to .taskmaster/docs/research/prisma-pooling-notes.md.
- Use pooled DATABASE_URL at runtime; DIRECT_URL for migrations/studio.
- Add pgbouncer and ssl params; avoid long transactions; set low connection_limit in serverless.
- Consider Accelerate/Data Proxy for Edge.


## 6. Makefile: lint, format, typecheck, unit, e2e, prisma, check, ci [review]
### Dependencies: None
### Description: Create a Makefile to orchestrate local and CI commands for lint/format/typecheck/tests/e2e and Prisma utilities.
### Details:
Targets (pnpm examples):\n- install: pnpm install\n- dev: pnpm dev\n- build: pnpm build\n- typecheck: pnpm tsc --noEmit\n- lint: pnpm eslint .\n- lint-fix: pnpm eslint . --fix\n- format: pnpm prettier --write "**/*.{js,jsx,ts,tsx,md,css,scss,json}"\n- format-check: pnpm prettier --check "**/*.{js,jsx,ts,tsx,md,css,scss,json}"\n- test: pnpm vitest run\n- test-watch: pnpm vitest\n- e2e: pnpm playwright test\n- e2e-headed: pnpm playwright test --headed\n- prisma-format: pnpm prisma format\n- prisma-validate: pnpm prisma validate\n- prisma-migrate: pnpm prisma migrate dev -n $(name)\n- prisma-seed: pnpm prisma db seed\n- prisma-studio: pnpm prisma studio\n- check: make prisma-format prisma-validate typecheck lint test\n- ci: pnpm prisma format && pnpm prisma validate && pnpm typecheck && pnpm eslint . && pnpm vitest run && pnpm playwright test --reporter=line\nNotes: Only OpenAI and OpenRouter providers are supported. Optional Python worker targets (ruff/black/pytest) may be added later under a feature flag.

Tag: backend

